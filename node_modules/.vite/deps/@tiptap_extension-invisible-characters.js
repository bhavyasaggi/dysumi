import {
  AllSelection,
  Decoration,
  DecorationSet,
  Extension,
  Plugin,
  PluginKey
} from "./chunk-JBMDK5OD.js";
import "./chunk-5WRI5ZAA.js";

// ../../node_modules/@tiptap/extension-invisible-characters/dist/index.js
var stateReducer = (state, visible) => {
  if (visible === void 0) {
    return state;
  }
  return { ...state, visible };
};
var style = `.tiptap-invisible-character {
  height: 0;
  padding: 0;
  pointer-events: none;
  user-select: none;
  width: 0;
}

.tiptap-invisible-character::before {
  caret-color: inherit;
  color: #aaa;
  display: inline-block;
  font-style: normal;
  font-weight: 400;
  line-height: 1em;
  width: 0;
}

.tiptap-invisible-character--space::before {
  content: '·'
}

.tiptap-invisible-character--break::before {
  content: '¬'
}

.tiptap-invisible-character--paragraph::before {
  content: '¶'
}

.tiptap-invisible-character + img.ProseMirror-separator {
  height: 0 !important;
  pointer-events: none;
  user-select: none;
  width: 0 !important;
}

.is-empty[data-placeholder].has-focus > .tiptap-invisible-character {
  display: none;
}
`;
var createStyleTag = (style2, nonce) => {
  const tiptapStyleTag = document.querySelector("style[data-tiptap-extension-invisible-characters-style]");
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute("data-tiptap-extension-invisible-characters-style", "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
};
var getUpdatedRanges = ({ mapping }) => {
  const ranges = [];
  mapping.maps.forEach((stepMap, i) => {
    stepMap.forEach((_oldStart, _oldEnd, newStart, newEnd) => {
      ranges.push([mapping.slice(i + 1).map(newStart), mapping.slice(i + 1).map(newEnd)]);
    });
  });
  return ranges;
};
var InvisibleCharactersPluginKey = new PluginKey("invisibleCharacters");
var InvisibleCharactersPlugin = (state, options) => {
  const key = InvisibleCharactersPluginKey;
  const emptyDecorationSet = DecorationSet.create(state.doc, []);
  const addDecorationsBetweenPositions = (from, to, editorState, decorations) => {
    return options.builders.sort((builderA, builderB) => {
      if (builderA.priority > builderB.priority) {
        return 1;
      }
      return -1;
    }).reduce((newDecos, builder) => {
      return builder.createDecoration(from, to, editorState.doc, newDecos);
    }, decorations);
  };
  return new Plugin({
    key,
    state: {
      init: () => {
        const { $from, $to } = new AllSelection(state.doc);
        if (options.injectCSS && document) {
          createStyleTag(style, options.injectNonce);
        }
        return {
          visible: options.visible,
          decorations: addDecorationsBetweenPositions($from.pos, $to.pos, state, DecorationSet.empty)
        };
      },
      apply: (tr, pluginState, _, currentState) => {
        const newPluginState = stateReducer(pluginState, tr.getMeta("setInvisibleCharactersVisible"));
        const decorations = getUpdatedRanges(tr).reduce(
          (nextDecorations, [from, to]) => {
            return addDecorationsBetweenPositions(from, to, currentState, nextDecorations);
          },
          newPluginState.decorations.map(tr.mapping, tr.doc)
        );
        return {
          ...newPluginState,
          decorations
        };
      }
    },
    props: {
      decorations(editorState) {
        const pluginState = this.getState(editorState);
        const visible = pluginState == null ? void 0 : pluginState.visible;
        const decorations = pluginState == null ? void 0 : pluginState.decorations;
        return visible ? decorations : emptyDecorationSet;
      }
    }
  });
};
var createDecorationWidget = (pos, type, content) => {
  const createElement = () => {
    const newElement = document.createElement("span");
    newElement.classList.add("tiptap-invisible-character");
    newElement.classList.add(`tiptap-invisible-character--${type}`);
    if (content) {
      newElement.textContent = content;
    }
    return newElement;
  };
  return Decoration.widget(pos, createElement, {
    key: type,
    marks: [],
    side: 1e3
  });
};
var defaultPosition = (node, pos) => pos + node.nodeSize - 1;
var InvisibleNode = class {
  constructor(options) {
    this.predicate = options.predicate;
    this.type = options.type;
    this.position = options.position || defaultPosition;
    this.content = options.content;
    this.priority = options.priority || 100;
  }
  createDecoration(from, to, doc, decorations) {
    let newDecorations = decorations;
    doc.nodesBetween(from, to, (node, pos) => {
      if (this.test(node)) {
        const decorationPosition = this.position(node, pos);
        const oldDecorations = newDecorations.find(
          decorationPosition,
          decorationPosition,
          (spec) => spec.key === this.type
        );
        newDecorations = newDecorations.remove(oldDecorations).add(doc, [createDecorationWidget(decorationPosition, this.type, this.content)]);
      }
    });
    return newDecorations;
  }
  test(value) {
    return this.predicate(value);
  }
};
var HardBreakNode = class extends InvisibleNode {
  constructor() {
    super({
      type: "break",
      predicate: (node) => node.type === node.type.schema.nodes.hardBreak
    });
  }
};
var ParagraphNode = class extends InvisibleNode {
  constructor() {
    super({
      type: "paragraph",
      predicate: (node) => node.type === node.type.schema.nodes.paragraph
    });
  }
};
var textBetween = (from, to, doc) => {
  const positions = [];
  doc.nodesBetween(from, to, (node, pos) => {
    var _a;
    if (node.isText) {
      const offset = Math.max(from, pos) - pos;
      positions.push({
        pos: pos + offset,
        text: ((_a = node.text) == null ? void 0 : _a.slice(offset, to - pos)) || ""
      });
    }
  });
  return positions;
};
var InvisibleCharacter = class {
  constructor(options) {
    this.predicate = options.predicate;
    this.type = options.type;
    this.content = options.content;
    this.priority = options.priority || 100;
  }
  createDecoration(from, to, doc, decorations) {
    const textContent = textBetween(from, to, doc);
    return textContent.reduce((oldDecorations, currentPosition) => {
      return currentPosition.text.split("").reduce((innerDecorations, char, i) => {
        return this.test(char) ? innerDecorations.add(doc, [createDecorationWidget(currentPosition.pos + i, this.type, this.content)]) : innerDecorations;
      }, oldDecorations);
    }, decorations);
  }
  test(value) {
    return this.predicate(value);
  }
};
var SpaceCharacter = class extends InvisibleCharacter {
  constructor() {
    super({
      type: "space",
      predicate: (char) => char === " "
    });
  }
};
var InvisibleCharacters = Extension.create({
  name: "invisibleCharacters",
  addOptions() {
    return {
      visible: true,
      builders: [new SpaceCharacter(), new ParagraphNode(), new HardBreakNode()],
      injectCSS: true,
      injectNonce: void 0
    };
  },
  addProseMirrorPlugins() {
    return [InvisibleCharactersPlugin(this.editor.state, this.options)];
  },
  addStorage() {
    return {
      visibility: () => this.options.visible
    };
  },
  onBeforeCreate() {
    this.storage.visibility = () => {
      var _a;
      return (_a = InvisibleCharactersPluginKey.getState(this.editor.state)) == null ? void 0 : _a.visible;
    };
  },
  addCommands() {
    return {
      showInvisibleCharacters: (visibility = true) => ({ dispatch, tr }) => {
        if (dispatch) {
          tr.setMeta("setInvisibleCharactersVisible", visibility);
        }
        return true;
      },
      hideInvisibleCharacters: () => ({ dispatch, tr }) => {
        if (dispatch) {
          tr.setMeta("setInvisibleCharactersVisible", false);
        }
        return true;
      },
      toggleInvisibleCharacters: () => ({ dispatch, tr, state }) => {
        var _a;
        const visibility = !((_a = InvisibleCharactersPluginKey.getState(state)) == null ? void 0 : _a.visible);
        if (dispatch) {
          tr.setMeta("setInvisibleCharactersVisible", visibility);
        }
        return true;
      }
    };
  }
});
var index_default = InvisibleCharacters;
export {
  HardBreakNode,
  InvisibleCharacter,
  InvisibleCharacters,
  InvisibleNode,
  ParagraphNode,
  SpaceCharacter,
  index_default as default
};
//# sourceMappingURL=@tiptap_extension-invisible-characters.js.map
